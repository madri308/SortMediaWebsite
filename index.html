<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9655374788764860" crossorigin="anonymous"></script>
    <title>Organize Media By Orientation</title>
    <style>
        h1{
            font-family: WF Visual Sans,sans-serif;
        }

        h2{
            font-family: WF Visual Sans,sans-serif;
        }

        p{
            font-family: WF Visual Sans Text,sans-serif;
        }

/* CSS */
button, input[type="file"]::file-selector-button {
  align-items: center;
  background-color: #FFFFFF;
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: .25rem;
  box-shadow: rgba(0, 0, 0, 0.02) 0 1px 3px 0;
  box-sizing: border-box;
  color: rgba(0, 0, 0, 0.85);
  cursor: pointer;
  display: inline-flex;
  font-family: system-ui,-apple-system,system-ui,"Helvetica Neue",Helvetica,Arial,sans-serif;
  font-size: 16px;
  font-weight: 600;
  justify-content: center;
  line-height: 1.25;
  margin: 0;
  min-height: 3rem;
  padding: calc(.875rem - 1px) calc(1.5rem - 1px);
  position: relative;
  text-decoration: none;
  transition: all 250ms;
  user-select: none;
  -webkit-user-select: none;
  touch-action: manipulation;
  vertical-align: baseline;
  width: auto;
}

button:hover, input[type="file"]::file-selector-button:hover,
button:focus, input[type="file"]::file-selector-button:focus {
  border-color: rgba(0, 0, 0, 0.15);
  box-shadow: rgba(0, 0, 0, 0.1) 0 4px 12px;
  color: rgba(0, 0, 0, 0.65);
}

button:hover, input[type="file"]::file-selector-button:hover {
  transform: translateY(-1px);
}

button:active, input[type="file"]::file-selector-button:active {
  background-color: #F0F0F1;
  border-color: rgba(0, 0, 0, 0.15);
  box-shadow: rgba(0, 0, 0, 0.06) 0 2px 4px;
  color: rgba(0, 0, 0, 0.65);
  transform: translateY(0);
}
    </style>
</head>
<body>

    <header>
        <h1>Sort Media By Orientation</h1>
    </header>
    <aside></aside>
    <main>
        <h2>Select the folder with the media files you want to sort</h2>
        <input type="file" id="fileInput" multiple webkitdirectory>
        <button id="organizeButton">Organize Media</button>
        <div id="loadingMessage"></div>
    </main>
    <aside></aside>
    <footer>
        <p>If you have any question or suggestion, <a href="mailto:ememadrigal.em@gmail.com">send me an email</a></p>
    </footer>
    <script src="https://stuk.github.io/jszip/dist/jszip.min.js"></script>
    <script src="https://cdn.jsdelivr.net/g/filesaver.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.1.5/jszip.min.js"></script>
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-9655374788764860" crossorigin="anonymous"></script>
    <script>
        function getFileDimensions(file) {
            return new Promise((resolve, reject) => {
                if (file.type.startsWith('image')) {
                    // For images
                    const img = new Image();
                    img.onload = function() {
                        const dimensions = {
                            width: this.width,
                            height: this.height
                        };
                        resolve(dimensions);
                    };
                    img.onerror = function(error) {
                        reject(error);
                    };
                    img.src = URL.createObjectURL(file);
                } else if (file.type.startsWith('video')) {
                    // For videos
                    const video = document.createElement('video');
                    video.crossOrigin = 'anonymous'; // Enable cross-origin access if needed
        
                    video.onloadedmetadata = function() {
                        const dimensions = {
                            width: this.videoWidth,
                            height: this.videoHeight
                        };
                        resolve(dimensions);
                    };
        
                    video.onerror = function (error) {
                        reject(error);
                    };
        
                    video.src = URL.createObjectURL(file);
                } else {
                    // Unsupported file type
                    reject(new Error('Unsupported file type'));
                }
            });
        }
        
        async function processFiles(files, loadingMessage) {
            try {
                // Show loading message
                loadingMessage.textContent = 'Sorting files...';
        
                const verticalFiles = [];
                const horizontalFiles = [];
        
                // Categorize files into vertical and horizontal
                for (const file of files) {
                    const dimensions = await getFileDimensions(file);
                    if (dimensions.width > dimensions.height) {
                        horizontalFiles.push(file);
                    } else {
                        verticalFiles.push(file);
                    }
                }
        
                // Generate ZIP files for vertical and horizontal files separately
                if (verticalFiles.length > 0) {
                    const verticalChunks = chunkArray(verticalFiles, 5);
                    const verticalZipPromises = verticalChunks.map(async (chunk, index) => {
                        const zip = new JSZip();
                        await processFilesInZip(chunk, zip);
                        return zip.generateAsync({ type: 'blob' });
                    });
        
                    // Wait for all ZIPs to be generated
                    const verticalZipBlobs = await Promise.all(verticalZipPromises);
        
                    // Create download links for each vertical zip file
                    verticalZipBlobs.forEach((zipBlob, index) => {
                        const downloadLink = document.createElement('a');
                        downloadLink.href = URL.createObjectURL(zipBlob);
                        downloadLink.download = `vertical_files_${index + 1}.zip`;
                        downloadLink.click();
                    });
                }
        
                if (horizontalFiles.length > 0) {
                    const horizontalChunks = chunkArray(horizontalFiles, 5);
                    const horizontalZipPromises = horizontalChunks.map(async (chunk, index) => {
                        const zip = new JSZip();
                        await processFilesInZip(chunk, zip);
                        return zip.generateAsync({ type: 'blob' });
                    });
        
                    // Wait for all ZIPs to be generated
                    const horizontalZipBlobs = await Promise.all(horizontalZipPromises);
        
                    // Create download links for each horizontal zip file
                    horizontalZipBlobs.forEach((zipBlob, index) => {
                        const downloadLink = document.createElement('a');
                        downloadLink.href = URL.createObjectURL(zipBlob);
                        downloadLink.download = `horizontal_files_${index + 1}.zip`;
                        downloadLink.click();
                    });
                }
        
                // Hide loading message
                loadingMessage.textContent = 'Files sorted successfully!';
            } catch (error) {
                console.error("Error sorting files:", error);
                // Show error message
                loadingMessage.textContent = 'Error sorting files.';
            }
        }
        
        async function processFilesInZip(files, zip) {
            for (const file of files) {
                try {
                    const dimensions = await getFileDimensions(file);
        
                    // Check if the file is vertical or horizontal based on dimensions
                    if (dimensions.width > dimensions.height) {
                        // Horizontal file
                        zip.folder('horizontal').file(file.name, file);
                    } else {
                        // Vertical file
                        zip.folder('vertical').file(file.name, file);
                    }
                } catch (error) {
                    console.error("Error processing file:", error);
                }
            }
        }
        
        function chunkArray(array, chunkSize) {
            const result = [];
            for (let i = 0; i < array.length; i += chunkSize) {
                result.push(array.slice(i, i + chunkSize));
            }
            return result;
        }
        
        document.getElementById('organizeButton').addEventListener('click', async function() {
            const files = document.getElementById('fileInput').files;
            const loadingMessage = document.getElementById('loadingMessage');
        
            if (files.length > 0) {
                // Process all files
                await processFiles(files, loadingMessage);
        
                // Reset loading message
                loadingMessage.textContent = '';
            }
        });
    </script>
</body>
</html>